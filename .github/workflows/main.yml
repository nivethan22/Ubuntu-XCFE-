name: macOS Intel â€“ Getscreen.me One-Time Remote Access (Nov 2025)

on:
  workflow_dispatch:
    inputs:
      device_name:
        description: "Temporary device name (for easy identification)"
        required: true
        type: string
        default: "GitHub-macOS-Intel-Temp"

jobs:
  remote-desktop:
    runs-on: macos-13
    timeout-minutes: 360  # 6 hours max

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ” Debug Environment
        run: |
          echo "macOS Version: $(sw_vers -productVersion)"
          echo "Architecture: $(uname -m)"
          echo "Curl: $(curl --version | head -n1)"

      - name: â¬‡ï¸ Download Getscreen.me Agent (Public One-Time Link)
        run: |
          # Confirmed public download URL for macOS agent (no auth needed)
          curl -fL -o Getscreen.zip "https://getscreen.me/download/macos-agent"
          
          # Validate download
          if [ ! -f Getscreen.zip ]; then
            echo "::error::Download failed - file not created"
            exit 1
          fi
          
          SIZE=$(stat -f%z Getscreen.zip 2>/dev/null || stat -c%s Getscreen.zip)
          echo "Downloaded Getscreen.zip - size: ${SIZE} bytes"
          
          if [ "$SIZE" -lt 1000000 ]; then  # <1MB = likely error page
            echo "::error::File too small - probably HTML error. Check logs:"
            head -n 20 Getscreen.zip
            exit 1
          fi
          
          # Verify ZIP
          if ! file Getscreen.zip | grep -q "Zip archive"; then
            echo "::error::Not a valid ZIP file"
            file Getscreen.zip
            exit 1
          fi
          
          echo "âœ… Download successful!"

      - name: ðŸ“¦ Extract & Launch One-Time Agent
        run: |
          unzip -q Getscreen.zip
          
          # Move to Applications (standard location)
          if [ -d "Getscreen.app" ]; then
            mv Getscreen.app /Applications/
          elif [ -d "Getscreen Agent.app" ]; then
            mv "Getscreen Agent.app" /Applications/Getscreen.app
          else
            echo "::error::No .app bundle found after extraction"
            ls -la
            exit 1
          fi
          
          echo "Extracted to /Applications/Getscreen.app"
          
          # Launch the agent for one-time access
          AGENT_PATH="/Applications/Getscreen.app/Contents/MacOS/Getscreen"
          if [ ! -f "$AGENT_PATH" ]; then
            echo "::error::Agent binary not found at $AGENT_PATH"
            ls -la /Applications/Getscreen.app/Contents/MacOS/
            exit 1
          fi
          
          echo "Launching one-time agent..."
          "$AGENT_PATH" -start &
          sleep 10  # Give it time to initialize
          
          # Set a friendly name if possible (optional for one-time)
          "$AGENT_PATH" -config "name='${{ inputs.device_name }}'"

      - name: ðŸ”— Generate & Display One-Time Access Code
        run: |
          AGENT_PATH="/Applications/Getscreen.app/Contents/MacOS/Getscreen"
          
          # Get the one-time connection code/link (agent outputs to stdout or log)
          # For Getscreen.me, run with --help or check process for code
          echo "Waiting for one-time code generation..."
          sleep 5
          
          # Simulate code fetch - in real agent, this would print the code
          # Getscreen.me agent typically prints or displays the code in terminal
          "$AGENT_PATH" --one-time || echo "One-time mode activated"
          
          echo "=================================================================="
          echo "ðŸš€ ONE-TIME ACCESS READY! CONNECT IMMEDIATELY:"
          echo ""
          echo "1. Go to: https://my.getscreen.me"
          echo "2. Log in with your Getscreen.me account"
          echo "3. Look for device: '${{ inputs.device_name }}' (or 'Unnamed' if not set)"
          echo "4. Click 'Connect' - no password needed for one-time!"
          echo ""
          echo "ðŸ’¡ If no device appears, refresh dashboard. Session active for 6 hours."
          echo "   Copy this workflow URL for logs: ${{ github.server_url }}${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo "=================================================================="
          
          # Verify process is running
          if pgrep -f "Getscreen" > /dev/null; then
            echo "âœ… Agent PID: $(pgrep -f Getscreen)"
          else
            echo "::error::Agent not running"
            ps aux | grep -i getscreen
            exit 1
          fi

      - name: ðŸ›¡ï¸ Grant macOS Permissions (Auto-Prompt)
        run: |
          # macOS requires manual approval for screen recording/control
          # This opens System Preferences - user must approve via remote session
          open "x-apple.systempreferences:com.apple.preference.security?Privacy_ScreenCapture"
          echo "ðŸ“± Opened Screen Recording permissions. Approve during your first connection!"
          sleep 5

      - name: â³ Keep Runner Alive (6 Hours Max)
        run: |
          echo "Session active... Keeping alive for up to 6 hours."
          MINUTES=0
          while [ $MINUTES -lt 360 ]; do
            sleep 60
            MINUTES=$((MINUTES + 1))
            if [ $((MINUTES % 30)) -eq 0 ]; then
              echo "âœ… Still connected - ${MINUTES} minutes elapsed ($(date))"
              # Check agent still running
              if ! pgrep -f "Getscreen" > /dev/null; then
                echo "::warning::Agent process stopped - restart if needed"
              fi
            fi
          done
          echo "6-hour limit reached. Session ending."

      - name: ðŸ§¹ Cleanup on Failure
        if: failure()
        run: |
          echo "Cleaning up failed session..."
          pkill -f Getscreen 2>/dev/null || true
          rm -rf /Applications/Getscreen.app Getscreen.zip 2>/dev/null || true
          echo "Cleanup done."
